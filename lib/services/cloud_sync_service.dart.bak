import 'dart:io';
import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:firebase_storage/firebase_storage.dart';
import 'package:flutter/foundation.dart';
import '../models/saved_dream.dart';
import '../services/encryption_service.dart';

class CloudSyncService extends ChangeNotifier {
  final FirebaseAuth _auth = FirebaseAuth.instance;
  final FirebaseFirestore _firestore = FirebaseFirestore.instance;
  final FirebaseStorage _storage = FirebaseStorage.instance;
  final EncryptionService _encryptionService;

  bool _isEnabled = false;
  bool _isSyncing = false;
  DateTime? _lastSyncTime;
  String? _syncError;

  CloudSyncService(this._encryptionService);

  bool get isEnabled => _isEnabled;
  bool get isSyncing => _isSyncing;
  bool get isLoggedIn => _auth.currentUser != null;
  DateTime? get lastSyncTime => _lastSyncTime;
  String? get syncError => _syncError;
  String? get currentUserEmail => _auth.currentUser?.email;

  /// Inizializza il servizio
  Future<void> initialize() async {
    _auth.authStateChanges().listen((User? user) {
      if (user == null) {
        _isEnabled = false;
      }
      notifyListeners();
    });
  }

  /// Login con email e password
  Future<bool> signInWithEmailAndPassword(String email, String password) async {
    try {
      await _auth.signInWithEmailAndPassword(email: email, password: password);
      _isEnabled = true;
      _syncError = null;
      notifyListeners();
      return true;
    } on FirebaseAuthException catch (e) {
      _syncError = _getAuthErrorMessage(e.code);
      notifyListeners();
      return false;
    }
  }

  /// Registrazione con email e password
  Future<bool> createUserWithEmailAndPassword(
    String email,
    String password,
  ) async {
    try {
      await _auth.createUserWithEmailAndPassword(
        email: email,
        password: password,
      );
      _isEnabled = true;
      _syncError = null;
      notifyListeners();
      return true;
    } on FirebaseAuthException catch (e) {
      _syncError = _getAuthErrorMessage(e.code);
      notifyListeners();
      return false;
    }
  }

  /// Logout
  Future<void> signOut() async {
    await _auth.signOut();
    _isEnabled = false;
    _lastSyncTime = null;
    notifyListeners();
  }

  /// Sincronizza i sogni verso il cloud
  Future<bool> syncDreamsToCloud(List<SavedDream> dreams) async {
    if (!isLoggedIn || !_encryptionService.isInitialized) {
      return false;
    }

    _isSyncing = true;
    _syncError = null;
    notifyListeners();

    try {
      final userId = _auth.currentUser!.uid;
      final batch = _firestore.batch();

      for (final dream in dreams) {
        // Cripta i dati sensibili
        final encryptedDreamText = _encryptionService.encryptText(
          dream.dreamText,
        );
        final encryptedInterpretation = _encryptionService.encryptText(
          dream.interpretation,
        );

        final dreamData = {
          'id': dream.id,
          'dreamText': encryptedDreamText,
          'interpretation': encryptedInterpretation,
          'title': dream
              .title, // Il titolo può rimanere non crittografato per le ricerche
          'tags': dream.tags,
          'createdAt': dream.createdAt.toIso8601String(),
          'imageUrl': dream.imageUrl,
          'localImagePath': dream.localImagePath,
          'lastModified': FieldValue.serverTimestamp(),
        };

        final docRef = _firestore
            .collection('users')
            .doc(userId)
            .collection('dreams')
            .doc(dream.id);

        batch.set(docRef, dreamData, SetOptions(merge: true));

        // Upload dell'immagine se presente
        if (dream.localImagePath != null && dream.localImagePath!.isNotEmpty) {
          await _uploadImage(dream.id, dream.localImagePath!);
        }
      }

      await batch.commit();
      _lastSyncTime = DateTime.now();
      _isSyncing = false;
      notifyListeners();
      return true;
    } catch (e) {
      _syncError = 'Errore nella sincronizzazione: $e';
      _isSyncing = false;
      notifyListeners();
      return false;
    }
  }

  /// Scarica i sogni dal cloud
  Future<List<SavedDream>?> syncDreamsFromCloud() async {
    if (!isLoggedIn || !_encryptionService.isInitialized) {
      return null;
    }

    _isSyncing = true;
    _syncError = null;
    notifyListeners();

    try {
      final userId = _auth.currentUser!.uid;
      final querySnapshot = await _firestore
          .collection('users')
          .doc(userId)
          .collection('dreams')
          .orderBy('createdAt', descending: true)
          .get();

      final dreams = <SavedDream>[];
      for (final doc in querySnapshot.docs) {
        final data = doc.data();

        try {
          // Decripta i dati sensibili
          final decryptedDreamText = _encryptionService.decryptText(
            data['dreamText'],
          );
          final decryptedInterpretation = _encryptionService.decryptText(
            data['interpretation'],
          );

          final dream = SavedDream(
            id: data['id'],
            dreamText: decryptedDreamText,
            interpretation: decryptedInterpretation,
            title: data['title'],
            tags: List<String>.from(data['tags'] ?? []),
            createdAt: DateTime.parse(data['createdAt']),
            imageUrl: data['imageUrl'],
            localImagePath: data['localImagePath'],
          );

          dreams.add(dream);
        } catch (e) {
          print('Errore nella decrittazione del sogno ${doc.id}: $e');
          // Continua con gli altri sogni
        }
      }

      _lastSyncTime = DateTime.now();
      _isSyncing = false;
      notifyListeners();
      return dreams;
    } catch (e) {
      _syncError = 'Errore nel download: $e';
      _isSyncing = false;
      notifyListeners();
      return null;
    }
  }

  /// Upload di un'immagine
  Future<String?> _uploadImage(String dreamId, String localPath) async {
    try {
      final file = File(localPath);
      if (!await file.exists()) {
        return null;
      }

      final userId = _auth.currentUser!.uid;
      final storageRef = _storage
          .ref()
          .child('users')
          .child(userId)
          .child('dream_images')
          .child('$dreamId.jpg');

      final uploadTask = storageRef.putFile(file);
      final snapshot = await uploadTask;
      final downloadUrl = await snapshot.ref.getDownloadURL();

      return downloadUrl;
    } catch (e) {
      print('Errore nell\'upload dell\'immagine: $e');
      return null;
    }
  }

  /// Elimina un sogno dal cloud
  Future<bool> deleteDreamFromCloud(String dreamId) async {
    if (!isLoggedIn) return false;

    try {
      final userId = _auth.currentUser!.uid;

      // Elimina il documento
      await _firestore
          .collection('users')
          .doc(userId)
          .collection('dreams')
          .doc(dreamId)
          .delete();

      // Elimina l'immagine se presente
      try {
        await _storage
            .ref()
            .child('users')
            .child(userId)
            .child('dream_images')
            .child('$dreamId.jpg')
            .delete();
      } catch (e) {
        // L'immagine potrebbe non esistere, non è un errore critico
      }

      return true;
    } catch (e) {
      _syncError = 'Errore nell\'eliminazione: $e';
      notifyListeners();
      return false;
    }
  }

  /// Abilita/disabilita la sincronizzazione automatica
  void enableSync(bool enabled) {
    _isEnabled = enabled && isLoggedIn;
    notifyListeners();
  }

  String _getAuthErrorMessage(String errorCode) {
    switch (errorCode) {
      case 'user-not-found':
        return 'Utente non trovato';
      case 'wrong-password':
        return 'Password errata';
      case 'email-already-in-use':
        return 'Email già in uso';
      case 'weak-password':
        return 'Password troppo debole';
      case 'invalid-email':
        return 'Email non valida';
      case 'network-request-failed':
        return 'Errore di connessione';
      default:
        return 'Errore di autenticazione: $errorCode';
    }
  }

  /// Ottieni statistiche di sincronizzazione
  Map<String, dynamic> getSyncStats() {
    return {
      'isEnabled': _isEnabled,
      'isLoggedIn': isLoggedIn,
      'lastSyncTime': _lastSyncTime?.toIso8601String(),
      'userEmail': currentUserEmail,
      'hasError': _syncError != null,
      'errorMessage': _syncError,
    };
  }
}
